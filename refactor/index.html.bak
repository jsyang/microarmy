<html>
<style> canvas{position:absolute;left:0;top:0;} </style>
<script src=maps.js></script>
<script src=gLayer.js></script>
<script src=sLayer.js></script>
<body></body><script>
// Misc. helpers ///////////////////////////////////////////////////////////////

function RAND(min,max)
// Random integer from [min,max] (bound inclusive)
{
    return min+(Math.random()*(max-min+1))>>0;
}

// Enums ///////////////////////////////////////////////////////////////////////

var Enum=
{
    Team:
    {
        BLUE: 0,
        GREEN: 1
    },
    
    // Probably shouldn't go here, but it is hardcoded for now.
    // Corresponds to the the team color (default travel direction -- when there's no targets in sight!)
    Directions:
    [
        1,
        -1
    ],
    
    
    // or get attack direction via Math.pow(-1,Enum.Team[actualTeam]);
    
    TeamGoal:
    {
        ATTACK:0,
        DEFEND:1,
        RETREAT:2,
        MANUFACTURE:3,
        FORTIFY:4,
        
    },
    
    UnitClass:
    {
        INFANTRY:0,
        VEHICLES:1,
        AIRCRAFT:2,
                
        PILLBOX:3   // includes sandbag fortifications
    },
    
    InfantryAction:
    {
        MOVEMENT:0,
        ATTACK_STANDING:1,
        ATTACK_CROUCHING:2,
        ATTACK_PRONE:3,
        DEATH1:4,
        DEATH2:5
    },
    
    ProjectileTypes:
    {
        BULLET:0,
        SMALLROCKET:1,
        SMALLSHELL:2,
        HEAVYSHELL:3,
        HEAVYROCKET:4,
        NAPALMBOMBLET:5,
        TACTICALNUKE:6
    },
    
    // This is linked to the loading order of the FG resources in LoadResources().
    GFX:
    {    
        PROJECTILES:0,
        EXPLOSION1:1,
        
        // Enum.Team:
        //       BLUE   GREEN
        PISTOL:[    2,      4],
        ROCKET:[    3,      5],
        
        // Which frames do we actually do the shooting?
        ISFIRING:
        {//                    |             
            PISTOL:[0,1,0,1,0,0,0,1,0,1,0,0],
            ROCKET:[0,0,0,1,0,0,0,0,0,1,0,0]
        }
    }
};

// Base Entities ///////////////////////////////////////////////////////////////

function Pawn(x,y,team,target)
//  team    (ENUM) alliegance
//  target  (*) pointer to a goal: an enemy, usually
{    
    this.x=x;
    this.y=y;    
	this.team=team;
	this.target=target;
    
    // Animation
    this.frame=0;
    this.firstFrame=0;
    this.lastFrame=0;
}

function TeamInfo(x,y,team)
//  Holds the Team's reinforcements and resource info.
//  team    (ENUM) alliegance
{
    this.funds=500;
    this.fundRate=20;
    this.fundTime=50;
    
    this.reinforcementQueue=[];
    this.reinforcementTime=10;
    
    this.goal=Enum.TeamGoal.ATTACK;
}

// Structure classes ///////////////////////////////////////////////////////////
function Structure(x,y,type,team)
{
    var _=new Pawn(x,y);
    
    var typeInfo=
    ({//                                                            occupant    
    //  type            maxHealth       width   height  capacity    protection  GFXset              projectileType  sightRange  reloadTime  maxAmmo firingPorts   
        "pillbox":[     RAND(600,680),  14,     8,      2,          0.6,        Enum.GFX.PILLBOX,   PillboxMGBullet,8,          110,        6,      [[3,-4]]        ],
        "barracks":[    RAND(340,360),  36,     20,     20,         0.8,        Enum.GFX.BARRACKS,  undefined,      3,          0,          0,      undefined       ]
    })[type];
    
    _.health=health;
    _.personelCapacity=personelCapacity;
    _.type=type;

}

// Unit classes ////////////////////////////////////////////////////////////////

function Infantry(x,y,team,type,target)
//  type    (string) unit class
{
    var _=new Pawn(x,y,team,target);
    var r=Math.random;
        
    var typeInfo=
    ({
    //  type        health          berserkPotential    berserkTime     maxAmmo reloadTime  sightRange  GFXset          isFiring
        "rocket":[  RAND(60,80),    r()*0.5,            RAND(3,18),     1,      160,        9,          Enum.GFX.ROCKET,Enum.GFX.ISFIRING.ROCKET ],
        "pistol":[  RAND(30,70),    r()*0.19,           RAND(10,30),    2,      40,         7,          Enum.GFX.PISTOL,Enum.GFX.ISFIRING.PISTOL ]
    })[type];
    var i=0;
    _.health=           typeInfo[i++];
    _.berserkPotential= typeInfo[i++];
    _.berserkTime=      typeInfo[i++];
    _.maxAmmo=          typeInfo[i++];
    _.ammo=             _.maxAmmo;
    _.reloadTime=       typeInfo[i++];
    _.sightRange=       typeInfo[i++];
    _.GFXSET=           typeInfo[i++][team];
    _.isShotFrame=      typeInfo[i++];
    _.direction=        Enum.Directions[team];
    
    // Event flags / timers
    _.action=0;
    _.isReloading=0;
    _.isBerserk=0;
    _.corpseTime=180;                   // when this is 0, entity is deleted.
    _.class=Enum.UnitClass.INFANTRY;
    _.type=type;
    
    _.correctFacing=function()
    {        
		if(this.target) this.direction=(this.target.x>this.x)?1:-1;
        else            this.direction=Enum.Directions[this.team];
        
        this.firstFrame=(this.direction>0)? 6 : 0;
        this.lastFrame=(this.direction>0)?  11: 5;
    };
    
    _.clearTarget=function()
    {
        this.target=undefined;
        this.action=0;
    };
    
    _.findTarget=function()
    // Find the enemy.
    {        
        var sh=world.spatialHash;
        var x=this.x>>world.shWidth;
        var h=sh[x];
        // Find the partitions to check to find potential enemies.
        for(var s=this.sightRange+1, i=1; s-->world.shWidth; i++) 
        {
            if(sh[x-i]) h=h.concat(sh[x-i]);
            if(sh[x+i]) h=h.concat(sh[x+i]);
        }

        // Sort by dist to self.
        h.sort( function(a,b) { var ab=Math.abs; return ab(this.x-a.x)-ab(this.x-b.x); } );
        for(var i in h)
        {
            if(h[i].health<=0) continue;
            if(Math.abs(h[i].x-this.x)>>this.sightRange) break;     // Can't see it!
            if(h[i].team!=this.team) { this.target=h[i]; break; }   // Target acquired!
        }
        
        // May need to filter h by team later, right now it's okay.        
        this.correctFacing();
    };
    
    _.active=function()
    {
        if(this.health>0)
        {
            this.correctFacing();
            
            // Reloading: exhausted the mag.
            if(this.isReloading){ return this.isReloading--; }
            
            // Berserk: moving toward the original target for some time without
            //          regard to self-preservation or where the current target location is!
            //          once berserk is done, standard actions resume. 
            if(this.isBerserk){ this.isBerserk--; }
            else
            {                
                //if(!this.target || this.target.health<=0) this.findTarget();
                if(!this.target || this.target.health<=0 || (Math.abs(this.x-this.target.x)>>this.sightRange) )
                {
                    this.clearTarget();
                    this.findTarget();
                }
                else
                {
                    if(!this.action) this.action=RAND(Enum.InfantryAction.ATTACK_STANDING,Enum.InfantryAction.ATTACK_PRONE); 
                }
            }
            
            if(!this.ammo) { this.isReloading=this.reloadTime; this.ammo=this.maxAmmo; this.frame=this.firstFrame; return; }
            
            // Loop the animation by default if not dead.
            if(++this.frame>this.lastFrame) this.frame=this.firstFrame;
            
            if(this.action==Enum.InfantryAction.MOVEMENT) // Moving!
            {                
                this.x+=this.direction;
                var x=this.x;                
                
                if(!( x<0 || x>world.width-1 )) 
                {
                    this.y=world.heightmap[x];
                    return;
                }
                
                var d=Enum.Directions[this.team];
                // Out of bounds! Check win conditions
                if( (x<0 && d<0) || (x>world.width-1 && d>0) ) // Reach the enemy border: win
                {} // log.win(this.team);
                this.corpseTime=0;
                this.health=0;
            }
            else // Attacking!
            {
                var distTarget=Math.abs(this.x-this.target.x);
                if(distTarget<9)    // Melee distance: KILL OR BE KILLED
                {
                    if(Math.random()<this.berserkPotential)
                    {
                        this.target.health=0;
                        this.clearTarget();
                        // log.meleeKill(this.team);
                    }
                    return;
                }
                
                // Berserk!-- better now than never!
                if(Math.random()<this.berserkPotential)
                {  this.action=Enum.InfantryAction.MOVEMENT; return this.isBerserk=this.berserkTime; }
                
                if(this.frame==this.firstFrame && this.type=="pistol") audio.s.pistol.play();
                if(!this.isShotFrame[this.frame]) return;                
                
                var bulletDY=(this.action==Enum.InfantryAction.ATTACK_PRONE)? -2: -4;
                var bulletDX=(this.direction>0)? 5 : -5;
    
                var shotType=({
                //              accuracy        projectileType  strayDY
                    "rocket":[  [0.18,0.75],    SmallRocket,    RAND(-15,15)/100    ],
                    "pistol":[  [0.1,0.45],     Bullet,         RAND(-21,21)/100    ]
                })[this.type];                
                var i=0;
                var accuracy=       shotType[i++];
                var projectileType= shotType[i++];
                var strayDY=        shotType[i++];
                if(distTarget>40){  accuracy[0]-=0.02; accuracy[1]-=0.15; }
                if(distTarget>80){  accuracy[0]-=0.01; accuracy[1]-=0.08; }
                if(distTarget>120){ accuracy[0]-=0.01; accuracy[1]-=0.08; }
                if(distTarget>160){ accuracy[0]-=0.01; accuracy[1]-=0.08; }
                
                // Flight speed = 1<<2.
                world.projectiles.push(
                    new projectileType(this.x+bulletDX,this.y+bulletDY,this.team,this.target,this.direction<<2,((this.target.y-this.y-bulletDY)<<2)/distTarget+strayDY,accuracy)
                );
                
                this.ammo--;
            }
        }
        else
        {   
            if(this.action<Enum.InfantryAction.DEATH1)
            {
                [ audio.s.die1, audio.s.die2, audio.s.die3, audio.s.die4 ][RAND(0,3)].play();
                this.action=RAND(Enum.InfantryAction.DEATH1, Enum.InfantryAction.DEATH2);
                this.correctFacing();
                this.frame=this.firstFrame;
                // log.deaths[this.team]++;
                // log.unitLost(team,this.class);   // Enum.UnitClass.INFANTRY;                
            }
            else
            {
                if(this.frame<this.lastFrame) this.frame++;
                else this.corpseTime--;
            }
        }    
    };
    
    return _;
}

// Projectiles /////////////////////////////////////////////////////////////////

function Bullet(x,y,team,target,dx,dy,accuracy)
//  dx          (double) X distance to cover per tick
//  dy          (double) Y distance to cover per tick
//  accuracy    (double[]) chance to hit [bystanders, target bonus]
{
    var _=new Pawn(x,y,team,target);
    _.dx=dx;
    _.dy=dy;
    _.accuracy=accuracy;
    
    _.type=Enum.ProjectileTypes.BULLET;
    _.range=35;
    _.damage=20;
    _.fly=function()
    {
        this.y+=this.dy;
        this.x+=this.dx;
        
        // Out of bounds or hit the ground!
        if( this.x<0 || this.x>world.width-1 || this.y>world.heightmap[this.x>>0] ) this.range=0;
        if(!this.range) return;
        this.range--;
        
        // Get our 3 closest spatialHash partitions.
        var sh=world.spatialHash;
        var x=this.x>>world.shWidth;
        var h=sh[x];
        if(sh[x-1]) h=h.concat(sh[x-1]);
        if(sh[x+1]) h=h.concat(sh[x+1]);
        
        for(var i in h)
        {
            var unit=h[i];
            if(unit.team==this.team) continue; // No explicit friendly fire!
            
            var dx=this.x-unit.x; dx*=dx;
            var dy=this.y-unit.y; dy*=dy;
            if((dx+dy)>>4) continue;  // Not close enough!
            
            if(unit.health<=0) continue;
            var chanceToHit=this.accuracy[0];
            if(unit==this.target) chanceToHit+=this.accuracy[1];
            
            if(unit.class==Enum.UnitClass.INFANTRY)
            {
                switch(unit.action)
                {// Deeper stance compounds bonus against chance to hit.
                    case Enum.InfantryAction.ATTACK_PRONE:      chanceToHit-=0.07;
                    case Enum.InfantryAction.ATTACK_CROUCHING:  chanceToHit-=0.05;
                    break;                    
                }
            }
            
            if(Math.random()>chanceToHit) continue;            
            switch(this.type)
            {
                case Enum.ProjectileTypes.SMALLROCKET:  world.explosions.push(new SmallExplosion(this.x,this.y));  break;
                case Enum.ProjectileTypes.BULLET:       // default case.
            }
            unit.health-=this.damage;
            
            // Hit something, stop.
            this.range=0; return;
        }
    };
    return _;
}
    
function SmallRocket(x,y,team,target,dx,dy,accuracy)
{
    audio.s.rocket.play();
    
    var _=new Bullet(x,y,team,target,dx,dy,accuracy);
    _.type=Enum.ProjectileTypes.SMALLROCKET;
    _.range=90;
    return _;
}

function PillboxMGBullet(x,y,team,target,dx,dy,accuracy)
{
    var _=new Bullet(x,y,team,target,dx,dy,accuracy);
    _.range=70;
    _.damage=RAND(22,27);
    return _;
}

// Explosions and Special Effects //////////////////////////////////////////////

function SmallExplosion(x,y)
{
    audio.s.expsmall.play();
    //updateMSGS("Rocket explosion at "+i.x+".");
    
    var _=new Pawn(x,y);
    _.lastFrame=12;     // inclusive
    _.width=41;
    _.height=35;
    _.damage=12;
    _.explode=function()
    {
        // Get our 3 closest spatialHash partitions.
        var sh=world.spatialHash;
        var x=this.x>>world.shWidth;
        var h=sh[x];
        if(sh[x-1]) h=h.concat(sh[x-1]);
        if(sh[x+1]) h=h.concat(sh[x+1]);
        
        for(var i in h)
        {
            var unit=h[i];
            var dx=this.x-unit.x; dx*=dx;
            var dy=this.y-unit.y; dy*=dy;
            if((dx+dy)>>9) continue;  // Not close enough!
            unit.health-=this.damage;
        }
        this.frame++;
    };
    return _;
}

// Special Entities ///////////////////////////////////////////////////////////

/*
    Audio channels (HTML5 only!)
    At least one channel for each sound, multiple channels for more frequent sounds.
    Groups: gunfire, death sounds, explosions and specials, music, gamestate sounds
    
    These are fully defined within world.loadResources()
*/
var audio;
var music;

var world=new (function()
{
    this.w=2490;
    this.h=192;    
    
    // Drawing contexts.
    this.BG=undefined;
    this.FG=undefined;
    this.FGimgs=undefined;
    
    // Terrain heightmap.
    this.heightmap=[];    
    
    // Hash array contains partitions (shWidth 64 (1<<6) pixels) of the gamefield    
    this.shWidth=6;
    this.newSpatialHash=function()
    {
        var newSH=[];
        for(var i=(this.w>>this.shWidth)+1; i--;) newSH.push([]);
        return newSH;
    };
    this.spatialHash=this.newSpatialHash();
    
    // Entity lists: STUFF that's alive
    this.infantry=[];
    this.vehicles=[];
    this.aircraft=[];
    this.projectiles=[];
    this.explosions=[];
    this.structures=[];
    
    this.loadResources=function()
    // Load the graphics and audio; setup things related to resources
    {
        // Fill the heightmap and draw the background -- "props"
        var g_BG=new gLayer(map,[world.w,world.h],function(g)
        {
            var w=g.w, h=g.h;
            g.c.drawImage(g.i[0],0,0);
            var d=g.c.getImageData(0,0,w,h).data;      
            for(var x=w;x--;)
            {
                for(var y=h-1; d[(y*w+x)*4+3];) y--;
                world.heightmap.push(y);
            }
            world.heightmap.reverse();
            g.c.drawImage(g.i[1],0,0);
            g.c.drawImage(g.i[0],0,0);        
            world.BG=g.c;
        });
        
        var g_FG=new gLayer([
        
            // Special Effects
            "gfx/fire0.png",
            "gfx/exp1.png",
            
            // Units
            "gfx/pistol0.png", "gfx/rocket0.png",
            "gfx/pistol1.png", "gfx/rocket1.png"
            
            // Todo: Vehicles
            // Todo: Aircraft
            // Todo: Structures
            // Todo: Debris particles
            
        ],[world.w,world.h],function(g)
        {
            world.FG=g.c;
            world.FGimgs=g.i;
        });
        
        audio=new sLayer(
        {
            pistol:{    src:"snd/pistol",   channels:5  },
            rocket:{    src:"snd/rocket",   channels:5  },
            
            die1:{      src:"snd/die1",     channels:6  },
            die2:{      src:"snd/die2",     channels:6  },
            die3:{      src:"snd/die3",     channels:6  },
            die4:{      src:"snd/die4",     channels:6  },
            
            expsmall:{  src:"snd/expsmall", channels:6  },
            accomp:{    src:"snd/accomp",   channels:1  }
            
        });
    };
    
    this.run=function()
    // Do a bunch of stuff at once: blit, process game events
    // Maybe separate this later? Doesn't make sense to do it right now.
    {        
        var FG=world.FG;
        var FGimgs=world.FGimgs;
        world.FG.clearRect(0,0,world.w,world.h);
        // Viewport coords
        var vw=window.innerWidth;
        var vs=document.body.scrollLeft;
        
        var newSpatialHash=this.newSpatialHash();

        // Handle Infantry
        var newInfantry=[];
        for(var i in world.infantry)
        {
            var a=world.infantry[i];
            
            if(a.x>vs && a.x<vs+vw) // cull out-of-scene entities
            FG.drawImage(FGimgs[a.GFXSET],a.frame*8,a.action*8,8,8,a.x-3,a.y-7,8,8);
            
            a.active();
            if(a.health>0)      newSpatialHash[a.x>>world.shWidth].push(a);
            if(a.corpseTime)    newInfantry.push(a);
            //else log.unitRot();   // or .unitRust() for vehicles
        }
        world.infantry=newInfantry;
        
        // Handle Projectile
        var newProjectiles=[];
        for(var i in world.projectiles)
        {
            var a=world.projectiles[i];
            
            if(a.x>vs && a.x<vs+vw) // cull out-of-scene entities
            FG.drawImage(FGimgs[Enum.GFX.PROJECTILES],(a.dx<0)?0:3,a.type*3,3,3,a.x-2,a.y-2,3,3);
            
            a.fly();
            if(a.range) newProjectiles.push(a);
        }
        world.projectiles=newProjectiles;        
        
        // Handle Explosions
        var newExplosions=[];
        for(var i in world.explosions)
        {
            var a=world.explosions[i];            
            var f=a.frame;            
            var w=a.width;
            var h=a.height;            
            
            if(a.x>vs && a.x<vs+vw) // cull out-of-scene entities
            FG.drawImage(FGimgs[Enum.GFX.EXPLOSION1],f*w,0,w,h,a.x-(w>>1),a.y-(h>>1),w,h);
            
            a.explode();
            if(a.frame>a.lastFrame) continue;            
            newExplosions.push(a);
        }
        world.explosions=newExplosions;
        
        // Reset the spatialHash for the next cycle!
        world.spatialHash=newSpatialHash;
    };
    
})();    
    

////////////////////////////////////////////////////////////////////////////////    
// Throwaway events and other testing stuff beyond this point! /////////////////
////////////////////////////////////////////////////////////////////////////////
    
function makeInfantry(team) {
    var t=(!RAND(0,18))? "rocket":"pistol";
    if(team==0) world.infantry.push(new Infantry(20,0,0,t));
    else world.infantry.push(new Infantry(2420,0,1,t));
    setTimeout("makeInfantry("+team+")",RAND(200,10200));
};
    
window.onload=function()
{
    world.loadResources();
    setInterval("world.run()",40);
    makeInfantry(Enum.Team.GREEN);
    makeInfantry(Enum.Team.BLUE);
    
};
window.onclick=function(e)
{
    world.explosions.push(new SmallExplosion(e.pageX,e.pageY));
};
</script></html>

