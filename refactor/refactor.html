<html>
<style> canvas{position:absolute;left:0;top:0;} </style>
<script src=maps.js></script>
<script src=gLayer.js></script>
<script src=sLayer.js></script>
<body></body><script>
// Data Generation /////////////////////////////////////////////////////////////

function RAND(min,max)
// Random integer from [min,max] (bound inclusive)
{
    return min+(Math.random()*(max-min+1))>>0;
}

// Enums ///////////////////////////////////////////////////////////////////////

var Enum=
{
    Team:
    {
        BLUE: 0,    BLUEDIRECTION: -1,
        GREEN: 1,   GREENDIRECTION: 1
    },
    // or get attack direction via Math.pow(-1,Enum.Team[actualTeam]);
    
    TeamGoal:
    {
        ATTACK:0,
        DEFEND:1,
        RETREAT:2,
        MANUFACTURE:3,
        FORTIFY:4,
        
    },
    
    UnitClass:
    {
        INFANTRY:0,
        VEHICLES:1,
        AIRCRAFT:2,
                
        PILLBOX:3   // includes sandbag fortifications
    },
    
    InfantryAction:
    {
        MOVEMENT:0,
        ATTACK_STANDING:1,
        ATTACK_CROUCHING:2,
        ATTACK_PRONE:3,
        DEATH1:4,
        DEATH2:5
    },
    
    ProjectileTypes:
    {
        BULLET:0,
        SMALLROCKET:1,
        SMALLSHELL:2,
        HEAVYSHELL:3,
        HEAVYROCKET:4,
        NAPALMBOMBLET:5,
        TACTICALNUKE:6
    },
    
    // This is linked to the loading order of the FG resources in LoadResources().
    GFX:
    {
        PROJECTILES:0,
        EXPLOSION1:1,
        
        // Enum.Team:
        //       BLUE   GREEN
        PISTOL:[    2,      4],
        ROCKET:[    3,      5]
    }
};

// Base Entities ///////////////////////////////////////////////////////////////

function Pawn(x,y,team,target)
//  team    (ENUM) alliegance
//  target  (*) pointer to a goal: an enemy, usually
{    
    this.x=x;
    this.y=y;    
	this.team=team;
	this.target=target;
    
    // Animation
    this.frame=0;
    this.lastFrame=0;
}

function TeamInfo(x,y,team)
//  Holds the Team's reinforcements and resource info.
//  team    (ENUM) alliegance
{
    this.funds=500;
    this.fundRate=20;
    this.fundTime=50;
    
    this.reinforcementQueue=[];
    this.reinforcementTime=10;
    
    this.goal=Enum.TeamGoal.ATTACK;
}

// Unit classes ////////////////////////////////////////////////////////////////

function Infantry(x,y,team,type,target)
//  type    (string) unit class
{   
    var _=new Pawn(x,y,team,target);    
    var r=Math.random;
        
    var typeInfo=
    {
    //  type        health          berserkPotential    berserkTime     reloadTime  sightRange  GFXset
        "rocket":[  RAND(60,80),    r()*0.3,            RAND(3,18),     160,        8,          Enum.GFX.ROCKET ],
        "pistol":[  RAND(30,70),    r()*0.7,            RAND(10,50),     25,        6,          Enum.GFX.PISTOL ]
    };
    var i=0;
    _.health=           typeInfo[type][i++];
    _.berserkPotential= typeInfo[type][i++];
    _.berserkTime=      typeInfo[type][i++];
    _.reloadTime=       typeInfo[type][i++];
    _.sightRange=       typeInfo[type][i++];    
    _.GFXSET=           typeInfo[type][i++][team];
        
    // Event flags / timers
    _.isReloading=0;
    _.isBerserk=0;
    _.corpseTime=180;
    _.class=Enum.UnitClass.INFANTRY;
    
    // Game events
    this.clearTarget;   // resetTarget()
    this.checkTarget;   // check for and head in the direction of new targets to attack
    this.active;        // highest level "alive" status: check if alive carry out movement, attacking, death.
                        // if dead lay out the corpse until it rots.
    
    return _;
}

// Projectiles /////////////////////////////////////////////////////////////////

function Bullet(x,y,team,target,dx,dy,accuracy)
//  dx          (double) X distance to cover per tick
//  dy          (double) Y distance to cover per tick
//  accuracy    (double[]) chance to hit [target, bystanders]
{   
    var _=new Pawn(x,y,team,target);
    _.dx=dx;
    _.dy=dy;
    _.accuracy=accuracy;
    
    _.type=Enum.ProjectileTypes.BULLET;
    _.range=35;
    _.fly=function()
    {
        // Hit the ground!
        if(this.y>world.heightmap[this.x>>0]) this.range=0;
        if(!this.range) return;
        this.range--;

        this.y+=this.dy;
        this.x+=this.dx;
        
        // Get our 3 closest spatialHash partitions.
        var sh=world.spatialHash;
        var x=this.x>>6;
        var h=sh[x];
        if(sh[x-1]) h=h.concat(sh[x-1]);
        if(sh[x+1]) h=h.concat(sh[x+1]);
        
        for(var i in sh)
        {
            var unit=sh[i];
            if(unit.team==this.team) continue; // No explicit friendly fire!
            
            var dx=this.x-unit.x; dx*=dx;
            var dy=this.y-unit.y; dy*=dy;
            if((dx+dy)>>3) continue;  // Not close enough!
            
            if(unit.health<=0) continue;
            var chanceToHit=this.accuracy[0];
            if(unit==this.target) chanceToHit+=this.accuracy[1];
            
            if(unit.class==Enum.UnitClass.INFANTRY)
            {
                switch(unit.action)
                {// Deeper stance compounds bonus against chance to hit.
                    case Enum.InfantryAction.ATTACK_PRONE:      chanceToHit-=0.07;
                    case Enum.InfantryAction.ATTACK_CROUCHING:  chanceToHit-=0.05;
                    break;                    
                }
            }
            
            if(Math.random()>chanceToHit) continue;            
            switch(this.type)
            {
                case Enum.ProjectileTypes.SMALLROCKET:  world.stuff.explosions.push(new SmallExplosion(this.x,this.y));  break;
                case Enum.ProjectileTypes.BULLET:       // default case.
            }
            unit.health-=15;
            
            // Hit something, stop.
            this.range=0; break;
        }
    };
    return _;
}
    
function SmallRocket(x,y,team,target,dx,dy,accuracy)
{
    audio.s.rocket.play();
    
    var _=new Bullet(x,y,team,target,dx,dy,accuracy);
    _.type=Enum.ProjectileTypes.SMALLROCKET;
    _.range=90;
    return _;
}

// Explosions and Special Effects //////////////////////////////////////////////

function SmallExplosion(x,y)
{
    audio.s.expsmall.play();
    //updateMSGS("Rocket explosion at "+i.x+".");
    
    var _=new Pawn(x,y);
    _.lastFrame=12;     // inclusive
    _.width=41;
    _.height=35;
    _.damage=2;
    _.explode=function()
    {
        // Get our 3 closest spatialHash partitions.
        var sh=world.spatialHash;
        var x=this.x>>6;
        var h=sh[x];
        if(sh[x-1]) h=h.concat(sh[x-1]);
        if(sh[x+1]) h=h.concat(sh[x+1]);
        
        for(var i in sh)
        {
            var unit=sh[i];
            var dx=this.x-unit.x; dx*=dx;
            var dy=this.y-unit.y; dy*=dy;
            var ww=this.width>>1; ww*=ww;
            if(ww-dx-dy>0) continue;  // Not close enough!
            unit.health-=this.damage;
        }
        this.frame++;
    };
    return _;
}

// Special Entities ///////////////////////////////////////////////////////////

/*
    Audio channels (HTML5 only!)
    At least one channel for each sound, multiple channels for more frequent sounds.
    Groups: gunfire, death sounds, explosions and specials, music, gamestate sounds
*/
var audio;
var music;

var world=new (function()
{
    this.w=2490;
    this.h=192;
    
    // Drawing contexts.
    this.BG=undefined;
    this.FG=undefined;
    this.FGimgs=undefined;
    
    // Terrain heightmap.
    this.heightmap=[];    
    
    // Hash array contains partitions (width 64 pixels) of the gamefield
    this.spatialHash=[];
    this.clearSpatialHash=function()
    {
        this.spatialHash=[];
        for(var i=(this.w/64+1)>>0; i--;) this.spatialHash.push([]);
    }; this.clearSpatialHash();
        
    // Entity lists: STUFF that's alive
    this.infantry=[];
    this.vehicles=[];
    this.aircraft=[];
    this.projectiles=[];
    this.explosions=[];
    this.structures=[];
    
    this.loadResources=function()
    // Load the graphics and audio; setup things related to resources
    {
        // Fill the heightmap and draw the background -- "props"
        var g_BG=new gLayer(map,[world.w,world.h],function(g)
        {
            var w=g.w, h=g.h;
            g.c.drawImage(g.i[0],0,0);
            var d=g.c.getImageData(0,0,w,h).data;      
            for(var x=w;x--;)
            {
                for(var y=h-1; d[(y*w+x)*4+3];) y--;
                world.heightmap.push(y);
            }
            world.heightmap.reverse();
            g.c.drawImage(g.i[1],0,0);
            g.c.drawImage(g.i[0],0,0);        
            world.BG=g.c;
        });
        
        var g_FG=new gLayer([
        
            // Special Effects
            "gfx/fire0.png",
            "gfx/exp1.png",
            
            // Units
            "gfx/pistol0.png", "gfx/rocket0.png",
            "gfx/pistol1.png", "gfx/rocket1.png"
            
            // Todo: Vehicles
            // Todo: Aircraft
            // Todo: Structures
            // Todo: Debris particles
            
        ],[world.w,world.h],function(g)
        {
            world.FG=g.c;
            world.FGimgs=g.i;
        });
        
        audio=new sLayer(
        {
            pistol:{    src:"snd/pistol",   channels:4  },
            rocket:{    src:"snd/rocket",   channels:3  },
            
            die1:{      src:"snd/die1",     channels:2  },
            die2:{      src:"snd/die2",     channels:2  },
            die3:{      src:"snd/die3",     channels:2  },
            die4:{      src:"snd/die4",     channels:2  },
            
            expsmall:{  src:"snd/expsmall", channels:2  },
            accomp:{    src:"snd/accomp",   channels:1  }
            
        });
    };
    
    this.run=function()
    // Do a bunch of stuff at once: blit, process game events
    // Maybe separate this later? Doesn't make sense to do it right now.
    {        
        var FG=world.FG;
        var FGimgs=world.FGimgs;
        world.FG.clearRect(0,0,world.w,world.h);
        
        var newSpatialHash=[];

        // Handle Infantry
        var newInfantry=[];
        for(var i in world.infantry)
        {
            var a=world.infantry[i];
            FG.drawImage(FGimgs[a.GFXSET],a.type*8,a.type*8,8,8,a.x-3,a.y-7,8,8);
            
            a.active();
            if(a.health>0)      newSpatialHash[a.x>>6].push(a);
            if(a.corpseTime)    newInfantry.push(a);
            //else updateMSGS("Corpse has decomposed.");
        }
        world.infantry=newInfantry;
        
        // Handle Projectile
        var newProjectiles=[];
        for(var i in world.projectiles)
        {
            var a=world.projectiles[i];
            FG.drawImage(FGimgs[Enum.GFX.PROJECTILES],3*((a.dx<0)?0:1),a.action*3,3,3,a.x-2,a.y-2,3,3);
            
            a.fly();
            if(a.range) newProjectiles.push(a);
        }
        world.projectiles=newProjectiles;        
        
        // Handle Explosions
        var newExplosions=[];
        for(var i in world.explosions)
        {
            var a=world.explosions[i];            
            var f=a.frame;            
            var w=a.width;
            var h=a.height;            
            FG.drawImage(FGimgs[Enum.GFX.EXPLOSION1],f*w,0,w,h,a.x-(w>>1),a.y-(h>>1),w,h);
            a.explode();
            if(a.frame>a.lastFrame) continue;            
            newExplosions.push(a);
        }
        world.explosions=newExplosions;
        
        // Reset the spatialHash for the next cycle!
        world.spatialHash=newSpatialHash;
    };
    
})();    
    
    
window.onload=function()
{
    world.loadResources();
    setInterval("world.run()",40);
};
window.onclick=function(e)
{
    world.explosions.push(new SmallExplosion(e.pageX,e.pageY));
};
</script></html>

