
define(function() {
  var Behaviors;
  return Behaviors = (function() {

    function Behaviors(_) {
      var k, v, _ref, _ref1;
      for (k in _) {
        v = _[k];
        this[k] = v;
      }
      if ('Trees' in _) {
        _ref = this['Trees'];
        for (k in _ref) {
          v = _ref[k];
          this['Trees'][k] = this.ConvertShortHand(this['Trees'][k]);
        }
      }
      if ('Decorators' in _) {
        _ref1 = this['Decorators'];
        for (k in _ref1) {
          v = _ref1[k];
          this['Decorators'][k] = this.ConvertShortHand(this['Decorators'][k]);
        }
      }
    }

    Behaviors.prototype.Decorators = {};

    Behaviors.prototype.Trees = {};

    Behaviors.prototype.Execute = function(btree, thisArg) {
      var id_, negate, result, subtree, _i, _j, _len, _len1, _ref, _ref1;
      if ((btree != null) && (btree.id != null)) {
        switch (btree.id) {
          case 'sequence':
            _ref = btree.children;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              subtree = _ref[_i];
              if (this.Execute(subtree, thisArg) === false) {
                return false;
              }
            }
            break;
          case 'selector':
            _ref1 = btree.children;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              subtree = _ref1[_j];
              if (this.Execute(subtree, thisArg) === true) {
                return true;
              }
            }
            break;
          default:
            negate = btree.id[0] === '!';
            id_ = negate ? btree.id.slice(1) : btree.id;
            subtree = this.Decorators[id_];
            if (subtree != null) {
              if (typeof subtree === 'boolean') {
                return subtree;
              } else {
                result = subtree.call(thisArg);
                if (negate) {
                  result = !result;
                }
                return result;
              }
            }
            subtree = this.Trees[id_];
            if (subtree != null) {
              result = this.Execute(subtree, thisArg);
              if (negate) {
                result = !result;
              }
              return result;
            } else {
              throw new Error("Tree/Decorator '" + id_ + "' not found!");
            }
        }
      } else {
        throw new Error('No behavior tree specified!');
      }
    };

    Behaviors.prototype.ConvertShortHand = function(code) {
      var btree;
      if (typeof code === 'string') {
        btree = code.replace(/\[/g, '{id:"').replace(/\]/g, '"}').replace(/\(/g, '{id:"selector",children:[').replace(/</g, '{id:"sequence",children:[').replace(/>/g, ']}').replace(/\)/g, ']}');
        return btree = eval("(" + btree + ")");
      } else {
        return code;
      }
    };

    return Behaviors;

  })();
});

// Generated by CoffeeScript 1.5.0-pre
